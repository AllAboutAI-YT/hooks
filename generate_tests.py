#!/usr/bin/env python3
"""
Script to automatically generate unit tests for Python files and run them.
This script is designed to be called from Claude Code hooks.
"""

import sys
import json
import os
import ast
import subprocess
import re
from pathlib import Path

def extract_functions_and_classes(file_path):
    """Extract function and class definitions from a Python file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        tree = ast.parse(content)
        functions = []
        classes = []
        
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                # Skip private functions and methods inside classes
                if not node.name.startswith('_'):
                    # Get function signature
                    args = [arg.arg for arg in node.args.args]
                    functions.append({
                        'name': node.name,
                        'args': args,
                        'docstring': ast.get_docstring(node)
                    })
            elif isinstance(node, ast.ClassDef):
                # Extract class methods
                methods = []
                for item in node.body:
                    if isinstance(item, ast.FunctionDef) and not item.name.startswith('_'):
                        args = [arg.arg for arg in item.args.args if arg.arg != 'self']
                        methods.append({
                            'name': item.name,
                            'args': args,
                            'docstring': ast.get_docstring(item)
                        })
                
                classes.append({
                    'name': node.name,
                    'methods': methods,
                    'docstring': ast.get_docstring(node)
                })
        
        return functions, classes
    except Exception as e:
        print(f"Error parsing {file_path}: {e}")
        return [], []

def generate_test_content(module_name, functions, classes):
    """Generate unit test content for the given functions and classes."""
    
    test_content = f"""#!/usr/bin/env python3
\"\"\"
Auto-generated unit tests for {module_name}.py
Generated by Claude Code hooks system.
\"\"\"

import unittest
import sys
import os

# Add the parent directory to sys.path to import the module
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from {module_name} import *
except ImportError as e:
    print(f"Could not import {module_name}: {{e}}")
    sys.exit(1)

"""
    
    # Generate tests for functions
    if functions:
        test_content += f"\nclass Test{module_name.title()}Functions(unittest.TestCase):\n"
        test_content += '    """Test cases for module functions."""\n\n'
        
        for func in functions:
            func_name = func['name']
            test_content += f"    def test_{func_name}(self):\n"
            test_content += f'        """Test {func_name} function."""\n'
            
            # Generate basic test cases based on function name patterns
            if 'prime' in func_name.lower():
                test_content += f"        # Test with known prime numbers\n"
                test_content += f"        self.assertTrue({func_name}(2))\n"
                test_content += f"        self.assertTrue({func_name}(17))\n"
                test_content += f"        self.assertFalse({func_name}(4))\n"
                test_content += f"        self.assertFalse({func_name}(1))\n"
            elif 'add' in func_name.lower() or 'sum' in func_name.lower():
                if len(func['args']) >= 2:
                    args_str = ', '.join(['1'] * len(func['args']))
                    expected = len(func['args'])
                    test_content += f"        result = {func_name}({args_str})\n"
                    test_content += f"        self.assertEqual(result, {expected})\n"
            elif 'calculate' in func_name.lower():
                test_content += f"        # Add specific test cases for {func_name}\n"
                test_content += f"        # result = {func_name}()  # Uncomment and modify as needed\n"
                test_content += f"        # self.assertIsNotNone(result)\n"
            else:
                # Generic test
                test_content += f"        # Add test cases for {func_name}\n"
                if func['args']:
                    test_content += f"        # Example: result = {func_name}(test_input)\n"
                    test_content += f"        # self.assertIsNotNone(result)\n"
                else:
                    test_content += f"        # Example: result = {func_name}()\n"
                    test_content += f"        # self.assertIsNotNone(result)\n"
            
            test_content += f"        pass  # Remove this when adding real tests\n\n"
    
    # Generate tests for classes
    for cls in classes:
        class_name = cls['name']
        test_content += f"\nclass Test{class_name}(unittest.TestCase):\n"
        test_content += f'    """Test cases for {class_name} class."""\n\n'
        
        test_content += f"    def setUp(self):\n"
        test_content += f'        """Set up test fixtures before each test method."""\n'
        test_content += f"        # self.instance = {class_name}()\n"
        test_content += f"        pass\n\n"
        
        if cls['methods']:
            for method in cls['methods']:
                method_name = method['name']
                test_content += f"    def test_{method_name}(self):\n"
                test_content += f'        """Test {method_name} method."""\n'
                test_content += f"        # Add test cases for {method_name}\n"
                test_content += f"        # result = self.instance.{method_name}()\n"
                test_content += f"        # self.assertIsNotNone(result)\n"
                test_content += f"        pass  # Remove this when adding real tests\n\n"
        else:
            test_content += f"    def test_instance_creation(self):\n"
            test_content += f'        """Test {class_name} instance creation."""\n'
            test_content += f"        # instance = {class_name}()\n"
            test_content += f"        # self.assertIsNotNone(instance)\n"
            test_content += f"        pass  # Remove this when adding real tests\n\n"
    
    # Add main block
    test_content += """
if __name__ == '__main__':
    unittest.main(verbosity=2)
"""
    
    return test_content

def run_tests(test_file_path):
    """Run the generated unit tests."""
    try:
        result = subprocess.run([
            sys.executable, test_file_path
        ], capture_output=True, text=True, cwd=os.path.dirname(test_file_path))
        
        return result.returncode, result.stdout, result.stderr
    except Exception as e:
        return -1, "", str(e)

def main():
    """Main function to be called by Claude Code hooks."""
    try:
        # Read hook input from stdin (as passed by Claude Code hooks)
        hook_input_str = sys.stdin.read().strip()
        if not hook_input_str:
            print("No input received from stdin")
            sys.exit(1)
        
        hook_input = json.loads(hook_input_str)
        
        tool_name = hook_input.get('tool_name', '')
        tool_input = hook_input.get('tool_input', {})
        
        # Only process Write tool calls for .py files
        if tool_name != 'Write':
            print(f"Skipping {tool_name} tool call")
            return
        
        file_path = tool_input.get('file_path', '')
        if not file_path.endswith('.py'):
            print(f"Skipping non-Python file: {file_path}")
            return
        
        # Skip test files themselves
        if file_path.endswith('_test.py') or file_path.endswith('test_.py') or 'test' in os.path.basename(file_path).lower():
            print(f"Skipping test file: {file_path}")
            return
        
        print(f"Generating tests for: {file_path}")
        
        # Extract module name
        module_name = os.path.splitext(os.path.basename(file_path))[0]
        
        # Extract functions and classes
        functions, classes = extract_functions_and_classes(file_path)
        
        if not functions and not classes:
            print(f"No testable functions or classes found in {file_path}")
            return
        
        # Generate test content
        test_content = generate_test_content(module_name, functions, classes)
        
        # Create test file
        test_file_path = file_path.replace('.py', '_test.py')
        
        with open(test_file_path, 'w', encoding='utf-8') as f:
            f.write(test_content)
        
        print(f"Generated test file: {test_file_path}")
        
        # Run the tests
        print("Running generated tests...")
        return_code, stdout, stderr = run_tests(test_file_path)
        
        print("=" * 50)
        print("TEST RESULTS:")
        print("=" * 50)
        print(stdout)
        if stderr:
            print("ERRORS:")
            print(stderr)
        print("=" * 50)
        print(f"Test exit code: {return_code}")
        
    except Exception as e:
        print(f"Error in generate_tests.py: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()